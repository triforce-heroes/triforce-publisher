import{batch as e,execute as n}from"./Database.js";export async function getEntries(e,s){let t=0,r=[];for(;;){let a=await n("SELECT [index], [sources], [translations], [sourceIndex], [translationIndex], [same], [sameSources] FROM [entries] WHERE [engine] = @engine LIMIT @limit OFFSET @offset",{engine:e,limit:s?50:1e3,offset:t});if(r.push(...a),s||0===a.length)break;t+=1e3}return r.map(e=>({...e,sources:JSON.parse(e.sources),translations:JSON.parse(e.translations)}))}export async function updateEntries(n,s){return e(s.map(e=>["INSERT INTO [entries] ([engine], [index], [resource], [reference], [context], [sources], [translations], [sourceIndex], [translationIndex], [same], [sameSources], [updatedAt]) VALUES (@engine, @index, @resource, @reference, @context, @sources, @translations, @sourceIndex, @translationIndex, @same, @sameSources, @updatedAt) ON CONFLICT ([engine], [index]) DO UPDATE SET [sources] = @sources, [translations] = @translations, [sourceIndex] = @sourceIndex, [translationIndex] = IIF([translatedAt] IS NOT NULL, [translationIndex], @translationIndex), [same] = @same, [sameSources] = @sameSources, [translatedAt] = IIF([translatedAt] IS NOT NULL, @updatedAt, NULL), [updatedAt] = @updatedAt",{engine:n,index:e.index,resource:e.resource,reference:e.reference,context:e.context??null,sources:JSON.stringify(e.sources),translations:JSON.stringify(e.translations),sourceIndex:e.sourceIndex??null,translationIndex:e.translationIndex??null,same:e.same??null,sameSources:e.sameSources??null,updatedAt:Date.now()}]))}