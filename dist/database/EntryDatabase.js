import{batch as e,execute as t}from"./Database.js";export async function getEntries(e,n){let s=0,a=[];for(;;){let r=await t("SELECT [index], [sources], [translations], [sourceIndex], [translationIndex], [same], [sameSources], [translatedBy] FROM [entries] WHERE [engine] = @engine LIMIT @limit OFFSET @offset",{engine:e,limit:n?50:1e3,offset:s});if(a.push(...r),n||0===r.length)break;s+=1e3}return a.map(e=>({...e,sources:JSON.parse(e.sources),translations:JSON.parse(e.translations)}))}export async function updateEntries(t,n){return e(n.map(e=>["INSERT INTO [entries] ([engine], [index], [resource], [reference], [context], [sources], [translations], [sourceIndex], [translationIndex], [translatedBy], [translatedAt], [same], [sameSources], [updatedAt]) VALUES (@engine, @index, @resource, @reference, @context, @sources, @translations, @sourceIndex, @translationIndex, @translatedBy, @translatedAt, @same, @sameSources, @updatedAt) ON CONFLICT ([engine], [index]) DO UPDATE SET [sources] = @sources, [translations] = @translations, [sourceIndex] = @sourceIndex, [translationIndex] = IIF([translatedAt] IS NOT NULL, [translationIndex], @translationIndex), [same] = @same, [sameSources] = @sameSources, [translatedBy] = IIF([translatedBy] IS NOT NULL, [translatedBy], @translatedBy), [translatedAt] = IIF([translatedAt] IS NOT NULL, @updatedAt, NULL), [updatedAt] = @updatedAt",{engine:t,index:e.index,resource:e.resource,reference:e.reference,context:e.context??null,sources:JSON.stringify(e.sources),translations:JSON.stringify(e.translations),sourceIndex:e.sourceIndex??null,translationIndex:e.translationIndex??null,translatedBy:e.translatedBy??null,translatedAt:e.translatedAt??null,same:e.same??null,sameSources:e.sameSources??null,updatedAt:Date.now()}]))}